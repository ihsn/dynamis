

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>3.2. Step 1: Creating a Population &mdash; DYNAMIS-POP  documentation</title>
  

  
  
  
  

  

  
  
    

  

  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="3.1. The Modgen Micro-simulation Technology" href="DYNAMIS-POP-Code-Intro.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> DYNAMIS-POP
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../Analysis/AnalysisInput/AnalysisInput-Index.html">1. Parameter Generation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Analysis/AnalysisOutput/AnalysisOutput-Index.html">2. Output Analysis</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="Model-Index.html">3. Technical Implementation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="DYNAMIS-POP-Code-Intro.html">3.1. The Modgen Micro-simulation Technology</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">3.2. Step 1: Creating a Population</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#model-characteristics">3.2.1. Model Characteristics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#file-input">3.2.1.1. File input</a></li>
<li class="toctree-l4"><a class="reference internal" href="#parameters">3.2.1.2. Parameters</a></li>
<li class="toctree-l4"><a class="reference internal" href="#model-output">3.2.1.3. Model Output</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#code-organization-and-a-classification-of-files">3.2.2. Code organization and a classification of files</a></li>
<li class="toctree-l3"><a class="reference internal" href="#model-documentation">3.2.3. Model Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#code-discussion">3.2.4. Code Discussion</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#model-info-mpp-model-information">3.2.4.1. model_info.mpp: Model Information</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-simulation-engine-model-core-mpp">3.2.4.2. The Simulation Engine: model_core.mpp</a></li>
<li class="toctree-l4"><a class="reference internal" href="#modgen-simulation-framework-modgen-time-based-mpp">3.2.4.3. Modgen Simulation Framework: modgen_time_based.mpp</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-country-version-specific-settings-countrycontext">3.2.4.4. The Country/Version-Specific Settings: _CountryContext</a></li>
<li class="toctree-l4"><a class="reference internal" href="#observationcore-mpp">3.2.4.5. ObservationCore.mpp</a></li>
<li class="toctree-l4"><a class="reference internal" href="#personcore-mpp">3.2.4.6. PersonCore.mpp</a></li>
<li class="toctree-l4"><a class="reference internal" href="#clockcore-mpp">3.2.4.7. ClockCore.mpp</a></li>
<li class="toctree-l4"><a class="reference internal" href="#calendaryearchange-mpp">3.2.4.8. CalendarYearChange.mpp</a></li>
<li class="toctree-l4"><a class="reference internal" href="#globalscore-mpp">3.2.4.9. GlobalsCore.mpp</a></li>
<li class="toctree-l4"><a class="reference internal" href="#microdataoutput-mpp">3.2.4.10. MicroDataOutput.mpp</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tables-mpp">3.2.4.11. Tables.mpp</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">DYNAMIS-POP</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="Model-Index.html">3. Technical Implementation</a> &raquo;</li>
        
      <li>3.2. Step 1: Creating a Population</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/Model/DYNAMIS-POP-Code-Step01.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="step-1-creating-a-population">
<span id="step-1-creating-a-population"></span><h1>3.2. Step 1: Creating a Population<a class="headerlink" href="#step-1-creating-a-population" title="Permalink to this headline">¶</a></h1>
<blockquote>
<div>The DYNAMIS-POP model development starts from a very generic basic template for typical continuous-time interacting population models. The model creates a starting population from a weighted file of observations. Depending on record weights and the desired simulation size, a population of simulation actors of equal weights is created from the observations, whereby individual observations might or might not be picked or picked various times. While not having much functionality at this point, the model provides a starting point ‘hiding’ some of the more tricky coding. Newcomers to Modgen are not required to fully understand all the code at this point: the following steps of model development introduce the basic concepts from a modelers perspective and provide simple step-by-step instructions for model building using Modgen.</div></blockquote>
<div class="section" id="model-characteristics">
<span id="model-characteristics"></span><h2>3.2.1. Model Characteristics<a class="headerlink" href="#model-characteristics" title="Permalink to this headline">¶</a></h2>
<div class="section" id="file-input">
<span id="file-input"></span><h3>3.2.1.1. File input<a class="headerlink" href="#file-input" title="Permalink to this headline">¶</a></h3>
<p>The micro-data population <strong>input file</strong> is a csv-file which currently contains only 6 variables:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Household</span> <span class="n">ID</span>             <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span><span class="o">..</span>
<span class="n">Weight</span>                   <span class="mf">2.125</span>
<span class="n">Year</span> <span class="n">of</span> <span class="n">birth</span>            <span class="mi">1966</span>
<span class="n">Sex</span>                      <span class="mi">0</span> <span class="n">female</span> <span class="mi">1</span> <span class="n">male</span>
<span class="n">Role</span> <span class="ow">in</span> <span class="n">family</span>           <span class="mi">0</span> <span class="n">head</span> <span class="mi">1</span> <span class="n">spouse</span> <span class="n">of</span> <span class="n">head</span> <span class="mi">2</span> <span class="n">child</span>  
</pre></div>
</div>
</div>
<div class="section" id="parameters">
<span id="parameters"></span><h3>3.2.1.2. Parameters<a class="headerlink" href="#parameters" title="Permalink to this headline">¶</a></h3>
<p>The model currently has 7 <strong>parameters</strong> organized into 2 groups: Starting population and Microdata output.</p>
<p>The starting population parameters are:</p>
<ul class="simple">
<li>The file name</li>
<li>The file size</li>
<li>The simulated sample size (which can be bigger or smaller than the file)</li>
<li>The real population size (to which all output is automatically scaled)</li>
</ul>
<p>The starting population is generated from a weighted file of observations. Depending on weights and the desired simulation size, a population of actors is created from the observations, whereby individual observations might or might not be picked or picked various times.</p>
<p>Parameters for micro-data output are:</p>
<ul class="simple">
<li>A check-box to switch output on/off</li>
<li>A file-name for the output file</li>
<li>Parameters for the timing of the first and the last output and output intervals</li>
</ul>
<p>Users can select at which time(s) output should be written.</p>
</div>
<div class="section" id="model-output">
<span id="model-output"></span><h3>3.2.1.3. Model Output<a class="headerlink" href="#model-output" title="Permalink to this headline">¶</a></h3>
<p>At this point, the model creates 3 output table as well as a micro-data output file (at one or periodic points in time selected by the user). File output is generated in csv format</p>
</div>
</div>
<div class="section" id="code-organization-and-a-classification-of-files">
<span id="code-organization-and-a-classification-of-files"></span><h2>3.2.2. Code organization and a classification of files<a class="headerlink" href="#code-organization-and-a-classification-of-files" title="Permalink to this headline">¶</a></h2>
<p>Modgen code is organized in .mpp files which can be classified into 4 groups.</p>
<ul class="simple">
<li><strong>Simulation engine:</strong> these files contain general model settings and the the code to run a simulation. Most of the code was automatically generated by the Modgen model wizard for time-based models. The code is mostly pure C++ and developers typically are not required to modify – or understand – it. The model is designed to run for various countries. All country and version specific code (like start year) are kept in a separate file _CountryContext.mpp.<ul>
<li>model_core.mpp</li>
<li>model_info.mpp</li>
<li>modgen_timebased</li>
<li>_CountryContext.mpp</li>
</ul>
</li>
</ul>
<ul class="simple">
<li><strong>Actor core files:</strong> Each Actor introduced in the model typically has a core file which contains general characteristics and functions of the actor. Our model at this point has four actor types, Observations (one for each record of the starting population file), Persons (the actual simulated entities representing the population), a Clock, and an actor Globals (for storing information easily accessible for all actors). Accordingly, there are four core files:<ul>
<li>ObservationCore.mpp</li>
<li>PersonCore.mpp</li>
<li>ClockCore.mpp</li>
<li>GlobalsCore.mpp</li>
</ul>
</li>
</ul>
<ul class="simple">
<li><strong>Regular modules:</strong> These are the modules developers typically spend most of their time on. Usually there is one such module by modeled behavior (like fertility, mortality, labor force participation) and policy system. At the moment, our model contains just one such module<ul>
<li>CalendarYearChange.mpp</li>
</ul>
</li>
</ul>
<ul class="simple">
<li><strong>Output modules:</strong> Modgen models produce three types of output: tables, micro-data, and a database of tracked actors used for a visualization tool called BioBrowser. The template provides two output files:<ul>
<li>Tables.mpp: contains all table output</li>
<li>MicroDataOutput.mpp: handles micro-data output</li>
</ul>
</li>
</ul>
<p>Besides the model code, modes come with one or mode parameter files, as well as micro-data input and output files.</p>
<ul class="simple">
<li><strong>Parameter .dat files:</strong> values are stored in one or more .dat files, which are readable text-files. Parameters are typically changed within the graphical user interface of the model.<ul>
<li>Default(PersonCore).dat: contains all model parameters. The file-name consists of a scenario name (Default) and the parameter file name. A user creating and saving a new scenario would generate a new file, e.g. NewScenario(PersonCore).</li>
</ul>
</li>
</ul>
<ul class="simple">
<li><strong>Microdata csv input and output</strong>: Micro-data in/output is organized in csv (comma separated values) files, which are readable text files. File-names can be chosen by the model user, e.g.<ul>
<li>startpop_austria.csv</li>
<li>micro_output_2050_austria.csv</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="model-documentation">
<span id="model-documentation"></span><h2>3.2.3. Model Documentation<a class="headerlink" href="#model-documentation" title="Permalink to this headline">¶</a></h2>
<p>Modgen models are self-documenting: Users can access a help file from the menu of the user interface.</p>
<p>Labels and notes for modules (as well as any symbols used in the program) are used for the automatically generated model help file for users, thus good documentation is not only best practice for model development, but also creates a detailed documentation for the user.</p>
<ul class="simple">
<li>A <strong>label</strong>: a one line description of the module</li>
<li>A <strong>note</strong>: a more detailed description of the module</li>
</ul>
<p>Example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//LABEL (CalendarYearChange, EN) Calendar Year Change</span>

<span class="cm">/*</span>
<span class="cm">    NOTE (CalendarYearChange, EN)</span>
<span class="cm">    This module handles calendar year changes. Before a year ends, the Person function YearEnd() </span>
<span class="cm">    is called by the Calendar clock actor. This is a point in time in which models typically update </span>
<span class="cm">    accounts and perform other end of year routines. Immediately after the year end, the YearStart() </span>
<span class="cm">    routine is called. This is when the calendar_year state is changed.  </span>
<span class="cm">*/</span>
</pre></div>
</div>
<p>Placed above or in the same line of a newly introduced symbol, labels can also be written as</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//EN The text of the label</span>
</pre></div>
</div>
<p>Labels are introduced by a language code (EN for English in our case) Modgen also support multilingual applications, in which these labels are translated into (an)other language(s). Besides their purpose of code documentation, these labels are used in the user interface, e.g. for column headings in tables or for the labeling of parameters.</p>
<p><img alt="Help System" src="Model\Figures/Step01_Help.png" /></p>
</div>
<div class="section" id="code-discussion">
<span id="code-discussion"></span><h2>3.2.4. Code Discussion<a class="headerlink" href="#code-discussion" title="Permalink to this headline">¶</a></h2>
<div class="section" id="model-info-mpp-model-information">
<span id="model-info-mpp-model-information"></span><h3>3.2.4.1. model_info.mpp: Model Information<a class="headerlink" href="#model-info-mpp-model-information" title="Permalink to this headline">¶</a></h3>
<p>This file is used for model documentation and contains a model description.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// The model version number</span>
<span class="n">version</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">//LABEL(model, EN) microWELT Model - Step 1 - Template</span>
<span class="cm">/* NOTE(model, EN)</span>
<span class="cm">   This model can serve as a starting point for the development of microWELT</span>
<span class="cm">*/</span>
</pre></div>
</div>
</div>
<div class="section" id="the-simulation-engine-model-core-mpp">
<span id="the-simulation-engine-model-core-mpp"></span><h3>3.2.4.2. The Simulation Engine: model_core.mpp<a class="headerlink" href="#the-simulation-engine-model-core-mpp" title="Permalink to this headline">¶</a></h3>
<p>This module contains general model settings and the simulation engine of the model. This module is part of the model template and developers typically are not required to modify – or understand – it’s code.</p>
<p>Model-specific code includes</p>
<ul class="simple">
<li>The creation of Observation actors reading the starting population file</li>
<li>The calculation of integer weights corresponding with the selected number of simulated actors</li>
<li>The creation of a starting population of equal weight Person actors</li>
<li>Deleting all Observation actors as they are not used anymore after the starting population was built.</li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// General Model Settings</span>
<span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>

<span class="n">model_type</span> <span class="n">time_based</span><span class="p">,</span> <span class="n">just_in_time</span><span class="p">;</span>        <span class="c1">// The model type</span>
<span class="n">options</span> <span class="n">packing_level</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>                  <span class="c1">// Reduces memory use at the expense of speed</span>
<span class="n">time_type</span> <span class="kt">double</span><span class="p">;</span>                           <span class="c1">// The data type used to represent time</span>

<span class="c1">// Other data types</span>
<span class="n">real_type</span>       <span class="kt">float</span><span class="p">;</span>
<span class="n">counter_type</span>    <span class="n">ushort</span><span class="p">;</span>
<span class="n">integer_type</span>    <span class="kt">short</span><span class="p">;</span>
<span class="n">index_type</span>      <span class="n">ulong</span><span class="p">;</span>

<span class="n">languages</span>                                   <span class="c1">// Supported languages</span>
<span class="p">{</span>
    <span class="n">EN</span> <span class="c1">// English</span>
<span class="p">};</span>


<span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// Simulation() is called by the simulation framework to simulate a replicate</span>
<span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>

<span class="kt">void</span> <span class="nf">Simulation</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">extern</span> <span class="kt">void</span> <span class="n">LogSimulationStart</span><span class="p">();</span> 
    <span class="k">extern</span> <span class="kt">void</span> <span class="n">SimulateEvents</span><span class="p">();</span> 
    <span class="n">LogSimulationStart</span><span class="p">();</span>                   <span class="c1">// Write simulation start message to log</span>

    <span class="c1">////////////////////////////////////////////////////////////////////</span>
    <span class="c1">// Start of the model-specific part of the simulation engine      //</span>
    <span class="c1">////////////////////////////////////////////////////////////////////</span>

    <span class="c1">// Create and open the input data file</span>
    <span class="n">input_csv</span> <span class="n">in_csv</span><span class="p">;</span>
    <span class="n">in_csv</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="n">MicroDataInputFile</span><span class="p">);</span>
    <span class="n">in_csv</span><span class="p">.</span><span class="n">read_header</span><span class="p">();</span>

    <span class="c1">// Create the Actor Globals</span>
    <span class="k">auto</span> <span class="n">prGlobals</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Globals</span><span class="p">();</span>
    <span class="n">prGlobals</span><span class="o">-&gt;</span><span class="n">Start</span><span class="p">();</span>

    <span class="c1">// Create the Clock</span>
    <span class="k">auto</span> <span class="n">prClock</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Clock</span><span class="p">();</span>
    <span class="n">prClock</span><span class="o">-&gt;</span><span class="n">Start</span><span class="p">();</span>
    
    <span class="c1">// Create observations</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="n">nJ</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">nJ</span> <span class="o">&lt;</span> <span class="n">MicroDataInputFileSize</span><span class="p">;</span> <span class="n">nJ</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">in_csv</span><span class="p">.</span><span class="n">read_record</span><span class="p">(</span><span class="n">nJ</span><span class="p">);</span>
        <span class="k">auto</span> <span class="n">paObservation</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Observation</span><span class="p">();</span>
        <span class="n">paObservation</span><span class="o">-&gt;</span><span class="n">Start</span><span class="p">(</span><span class="n">in_csv</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Set sample weights (obs_weight) in the observations to represent the (integer) number of </span>
    <span class="c1">// persons to be created out of each observation</span>
    <span class="kt">double</span> <span class="n">dSumWeights</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="n">nJ</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">nJ</span> <span class="o">&lt;</span> <span class="n">MicroDataInputFileSize</span><span class="p">;</span> <span class="n">nJ</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">dSumWeights</span> <span class="o">=</span> <span class="n">dSumWeights</span> <span class="o">+</span> <span class="n">asObservationAll</span><span class="o">-&gt;</span><span class="n">Item</span><span class="p">(</span><span class="n">nJ</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pmc</span><span class="p">[</span><span class="n">PMC_WEIGHT</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="n">nJ</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">nJ</span> <span class="o">&lt;</span> <span class="n">MicroDataInputFileSize</span><span class="p">;</span> <span class="n">nJ</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">double</span>  <span class="n">dWeight</span> <span class="o">=</span> <span class="n">asObservationAll</span><span class="o">-&gt;</span><span class="n">Item</span><span class="p">(</span><span class="n">nJ</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pmc</span><span class="p">[</span><span class="n">PMC_WEIGHT</span><span class="p">]</span> 
                    <span class="o">*</span> <span class="n">StartPopSampleSize</span> <span class="o">/</span> <span class="n">dSumWeights</span><span class="p">;</span>
        <span class="kt">int</span>     <span class="n">nWeight</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">dWeight</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">RandUniform</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">dWeight</span> <span class="o">-</span> <span class="n">nWeight</span><span class="p">)</span> <span class="n">nWeight</span><span class="o">++</span><span class="p">;</span>
        <span class="n">asObservationAll</span><span class="o">-&gt;</span><span class="n">Item</span><span class="p">(</span><span class="n">nJ</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">obs_weight</span> <span class="o">=</span> <span class="n">nWeight</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Calculate exact person weight: A small correction as all family members eventually inherit</span>
    <span class="c1">// the weight of the head which can be different from the integer weights assigned above</span>
    <span class="kt">long</span> <span class="n">SumSimActors</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="n">nH</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">nH</span> <span class="o">&lt;</span> <span class="n">asObservationHeads</span><span class="o">-&gt;</span><span class="n">Count</span><span class="p">();</span> <span class="n">nH</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Number family members </span>
        <span class="kt">int</span> <span class="n">nFamSize</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">asObservationNonHeads</span><span class="p">[</span><span class="n">asObservationHeads</span><span class="o">-&gt;</span><span class="n">Item</span><span class="p">(</span><span class="n">nH</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">fam_id</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">Count</span><span class="p">();</span>
        <span class="c1">// sum of person weights in family with all having same weight as head</span>
        <span class="n">SumSimActors</span> <span class="o">=</span> <span class="n">SumSimActors</span> <span class="o">+</span> <span class="n">nFamSize</span> <span class="o">*</span> <span class="n">asObservationHeads</span><span class="o">-&gt;</span><span class="n">Item</span><span class="p">(</span><span class="n">nH</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">obs_weight</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">asGlobals</span><span class="o">-&gt;</span><span class="n">Item</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">person_weight</span> <span class="o">=</span> <span class="n">StartPopSize</span><span class="o">/</span> <span class="n">SumSimActors</span><span class="p">;</span>
    
    <span class="c1">// Create the starting population</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">asObservationHeads</span><span class="o">-&gt;</span><span class="n">Count</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// First create the head</span>
        <span class="k">auto</span> <span class="n">paObservation</span> <span class="o">=</span> <span class="n">asObservationHeads</span><span class="o">-&gt;</span><span class="n">Item</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="k">auto</span> <span class="n">paPerson</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Person</span><span class="p">();</span>
        <span class="n">paPerson</span><span class="o">-&gt;</span><span class="n">Start</span><span class="p">(</span><span class="n">paObservation</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="c1">// And now all other members of this family</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">nJ</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">nJ</span> <span class="o">&lt;</span> <span class="n">asObservationNonHeads</span><span class="p">[</span><span class="n">paObservation</span><span class="o">-&gt;</span><span class="n">fam_id</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">Count</span><span class="p">();</span> <span class="n">nJ</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">auto</span> <span class="n">paOtherPerson</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Person</span><span class="p">();</span>
            <span class="n">paOtherPerson</span><span class="o">-&gt;</span><span class="n">Start</span><span class="p">(</span><span class="n">asObservationNonHeads</span><span class="p">[</span><span class="n">paObservation</span><span class="o">-&gt;</span><span class="n">fam_id</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">Item</span><span class="p">(</span><span class="n">nJ</span><span class="p">),</span> <span class="n">paPerson</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">paObservation</span><span class="o">-&gt;</span><span class="n">obs_weight</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Delete all observation actors</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">asObservationAll</span><span class="o">-&gt;</span><span class="n">Count</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">asObservationAll</span><span class="o">-&gt;</span><span class="n">Item</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Finish</span><span class="p">();</span>

    <span class="c1">// Close the microdata input file</span>
    <span class="n">in_csv</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>

    <span class="c1">////////////////////////////////////////////////////////////////////</span>
    <span class="c1">//   End of the model-specific part of the simulation engine      //</span>
    <span class="c1">////////////////////////////////////////////////////////////////////</span>

    
    <span class="n">SimulateEvents</span><span class="p">();</span>                       <span class="c1">// Simulate events until there are no more.</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="modgen-simulation-framework-modgen-time-based-mpp">
<span id="modgen-simulation-framework-modgen-time-based-mpp"></span><h3>3.2.4.3. Modgen Simulation Framework: modgen_time_based.mpp<a class="headerlink" href="#modgen-simulation-framework-modgen-time-based-mpp" title="Permalink to this headline">¶</a></h3>
<p>This module implements the Modgen simulation framework for time-based cross-compatible models. Cross-compatible models can also be compiled by the open-source language openM++. MicroWELT meets the standards of a cross-compatible model. This module is ignored by the OpenM++ compiler. It should not be necessary to modify any code in this module.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// Some String Contants used in the User-Interface</span>
<span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>

<span class="n">string</span> <span class="n">S_MODEL_FINISH</span><span class="p">;</span>              <span class="c1">//EN Finish</span>
<span class="n">string</span> <span class="n">S_MODEL_REPLICATE</span><span class="p">;</span>           <span class="c1">//EN Replicate</span>
<span class="n">string</span> <span class="n">S_MODEL_SIMULATION</span><span class="p">;</span>          <span class="c1">//EN Simulation</span>
<span class="n">string</span> <span class="n">S_MODEL_START</span><span class="p">;</span>               <span class="c1">//EN Start</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// SimulateEvents() simulates all events for all entities in the simulation.</span>
<span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>

<span class="kt">void</span> <span class="nf">SimulateEvents</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// Buffer for messages</span>
    <span class="k">const</span> <span class="kt">size_t</span> <span class="n">nBufSize</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>
    <span class="n">TCHAR</span> <span class="n">szBuffer</span><span class="p">[</span><span class="n">nBufSize</span><span class="p">];</span>

    <span class="c1">// Simulation member ordinal for progress reporting</span>
    <span class="kt">int</span> <span class="n">nSimulationMember</span> <span class="o">=</span> <span class="n">GetReplicate</span><span class="p">();</span>

    <span class="n">_stprintf_s</span><span class="p">(</span><span class="n">szBuffer</span><span class="p">,</span> <span class="n">nBufSize</span><span class="p">,</span> <span class="n">_T</span><span class="p">(</span><span class="s">&quot;%s %d: %s&quot;</span><span class="p">),</span> <span class="p">(</span><span class="n">LPCTSTR</span><span class="p">)</span><span class="n">ModelString</span><span class="p">(</span><span class="s">&quot;S_MODEL_REPLICATE&quot;</span><span class="p">),</span> 
        <span class="n">nSimulationMember</span><span class="p">,</span> <span class="p">(</span><span class="n">LPCTSTR</span><span class="p">)</span><span class="n">ModelString</span><span class="p">(</span><span class="s">&quot;S_MODEL_SIMULATION&quot;</span><span class="p">));</span>
    <span class="n">ProgressMessage</span><span class="p">(</span> <span class="n">szBuffer</span> <span class="p">);</span>

    <span class="kt">double</span> <span class="n">dCurrentTime</span> <span class="o">=</span> <span class="n">TIME_INFINITE</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">dStartTime</span> <span class="o">=</span> <span class="n">TIME_INFINITE</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">nLastProgressPercent</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">nThisProgressPercent</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span> <span class="o">!</span><span class="n">gpoEventQueue</span><span class="o">-&gt;</span><span class="n">Empty</span><span class="p">()</span> <span class="p">)</span> 
    <span class="p">{</span>

        <span class="c1">// get the time of next event, verify against the simulation end</span>
        <span class="n">dCurrentTime</span> <span class="o">=</span> <span class="n">gpoEventQueue</span><span class="o">-&gt;</span><span class="n">NextEvent</span><span class="p">();</span>

        <span class="c1">// Note the start time (time of first event) for progress indicator</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">dStartTime</span> <span class="o">==</span> <span class="n">TIME_INFINITE</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">dStartTime</span> <span class="o">=</span> <span class="n">dCurrentTime</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span> <span class="n">dCurrentTime</span> <span class="o">&gt;</span> <span class="n">SIMULATION_END</span><span class="p">()</span> <span class="o">||</span> <span class="n">gbInterrupted</span> <span class="o">||</span> <span class="n">gbCancelled</span> <span class="o">||</span> <span class="n">gbErrors</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">dCurrentTime</span> <span class="o">&gt;</span> <span class="n">SIMULATION_END</span><span class="p">())</span>
            <span class="p">{</span>
                <span class="c1">// age all actors to the simulation end time</span>
                <span class="n">gpoEventQueue</span><span class="o">-&gt;</span><span class="n">WaitUntilAllActors</span><span class="p">(</span> <span class="n">SIMULATION_END</span><span class="p">()</span> <span class="p">);</span>
            <span class="p">}</span>

            <span class="n">_stprintf_s</span><span class="p">(</span><span class="n">szBuffer</span><span class="p">,</span> <span class="n">nBufSize</span><span class="p">,</span> <span class="n">_T</span><span class="p">(</span><span class="s">&quot;%s %d: %s&quot;</span><span class="p">),</span> 
                <span class="p">(</span><span class="n">LPCTSTR</span><span class="p">)</span><span class="n">ModelString</span><span class="p">(</span><span class="s">&quot;S_MODEL_REPLICATE&quot;</span><span class="p">),</span> 
                <span class="n">nSimulationMember</span><span class="p">,</span> <span class="p">(</span><span class="n">LPCTSTR</span><span class="p">)</span><span class="n">ModelString</span><span class="p">(</span><span class="s">&quot;S_MODEL_FINISH&quot;</span><span class="p">));</span>
            <span class="n">ProgressMessage</span><span class="p">(</span> <span class="n">szBuffer</span> <span class="p">);</span>

            <span class="n">gpoEventQueue</span><span class="o">-&gt;</span><span class="n">FinishAllActors</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="k">else</span> 
        <span class="p">{</span>
            <span class="c1">// age all actors to the time of next event</span>
            <span class="n">gpoEventQueue</span><span class="o">-&gt;</span><span class="n">WaitUntil</span><span class="p">(</span> <span class="n">dCurrentTime</span> <span class="p">);</span>

            <span class="c1">// implement the next event</span>
            <span class="n">gpoEventQueue</span><span class="o">-&gt;</span><span class="n">Implement</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="c1">// Update progress indicator only if the integer percentage complete changes</span>
        <span class="c1">// (updates to the progress bar at every event are expensive).</span>
        <span class="n">nThisProgressPercent</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span> <span class="mi">100</span> <span class="o">*</span> <span class="p">(</span> <span class="n">dCurrentTime</span> <span class="o">-</span> <span class="n">dStartTime</span> <span class="p">)</span> <span class="o">/</span>
                                            <span class="p">(</span> <span class="n">SIMULATION_END</span><span class="p">()</span> <span class="o">-</span> <span class="n">dStartTime</span> <span class="p">)</span> <span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span> <span class="n">nThisProgressPercent</span> <span class="o">&gt;</span> <span class="n">nLastProgressPercent</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">TimeReport</span><span class="p">(</span> <span class="n">dCurrentTime</span> <span class="p">);</span>    <span class="c1">// update simulation progress</span>
            <span class="n">nLastProgressPercent</span> <span class="o">=</span> <span class="n">nThisProgressPercent</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// LogSimulationStart() writes a start message for the simulation member in the log.</span>
<span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>

<span class="kt">void</span> <span class="nf">LogSimulationStart</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// Buffer for messages</span>
    <span class="k">const</span> <span class="kt">size_t</span> <span class="n">nBufSize</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>
    <span class="n">TCHAR</span> <span class="n">szBuffer</span><span class="p">[</span><span class="n">nBufSize</span><span class="p">];</span>

    <span class="c1">// Simulation member ordinal for progress reporting</span>
    <span class="kt">int</span> <span class="n">nSimulationMember</span> <span class="o">=</span> <span class="n">GetReplicate</span><span class="p">();</span>

    <span class="n">_stprintf_s</span><span class="p">(</span><span class="n">szBuffer</span><span class="p">,</span> <span class="n">nBufSize</span><span class="p">,</span> <span class="n">_T</span><span class="p">(</span><span class="s">&quot;%s %d: %s&quot;</span><span class="p">),</span> <span class="p">(</span><span class="n">LPCTSTR</span><span class="p">)</span><span class="n">ModelString</span><span class="p">(</span><span class="s">&quot;S_MODEL_REPLICATE&quot;</span><span class="p">),</span> 
        <span class="n">nSimulationMember</span><span class="p">,</span> <span class="p">(</span><span class="n">LPCTSTR</span><span class="p">)</span><span class="n">ModelString</span><span class="p">(</span><span class="s">&quot;S_MODEL_START&quot;</span><span class="p">));</span>
    <span class="n">ProgressMessage</span><span class="p">(</span> <span class="n">szBuffer</span> <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="the-country-version-specific-settings-countrycontext">
<span id="the-country-version-specific-settings-countrycontext"></span><h3>3.2.4.4. The Country/Version-Specific Settings: _CountryContext<a class="headerlink" href="#the-country-version-specific-settings-countrycontext" title="Permalink to this headline">¶</a></h3>
<p>This file contains the country and starting year specific code. This is the only file to be adapded when porting the model to a new country context. Currently it only contains the total year range of teh simulation (from the first person born to the end of the projection horizon)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// Types</span>
<span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>

<span class="n">range</span> <span class="n">ALL_YEAR_RANGE</span> <span class="p">{</span> <span class="mi">1899</span><span class="p">,</span> <span class="mi">2150</span> <span class="p">};</span>             <span class="c1">//EN All calendar years    </span>
</pre></div>
</div>
</div>
<div class="section" id="observationcore-mpp">
<span id="observationcore-mpp"></span><h3>3.2.4.5. ObservationCore.mpp<a class="headerlink" href="#observationcore-mpp" title="Permalink to this headline">¶</a></h3>
<p>This module introduces an actor named ‘Observation’. Each Observation actor corresponds with a record of the starting population file and is created by the simulation engine before Person actors are created. Observation are weighted. According to the size of the simulated population selected by the user, the simulation engine creates integer-weights for each observation by rescaling the original weights and random-rounding. The new observation weights are then used by the simulation engine to decide if and how often an observation is used when creating Person actors (which clone the observation characteristics). After being used for creating the starting population, the observation actors are destroyed to free up teh memory space. Note that for this process, the weight of the household head is used for all members of a family.</p>
<p>This module is part of the model template and developers typically are not required to modify – or understand – it’s code. The exception is adding new variables to the starting population file which is a frequent requirement in model development:</p>
<p><strong>How to add a new variable to the starting population?</strong></p>
<ul class="simple">
<li>Add a new column to the csv micro-data file</li>
<li>in this module, extend the list of fields in the classification ‘PERSON_MICRODATA_COLUMNS’ no more coding is required and the variable is read in automatically</li>
<li>the new variable will typically be used in the Start() function of the Person actor where a corresponding state is initialized by its value. It is accessible using the new dimension name added to the list of fields as an index of the person-micro-column array pmc[NEW_FIELD]. See Code in the Start() function in PersonCore.mpp</li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// Dimensions                                                                                    </span>
<span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>

<span class="n">classification</span> <span class="n">PERSON_MICRODATA_COLUMNS</span>         <span class="c1">//EN fields in the microdata input file </span>
<span class="p">{</span>
    <span class="n">PMC_HHID</span><span class="p">,</span>                                   <span class="c1">//EN Household ID</span>
    <span class="n">PMC_WEIGHT</span><span class="p">,</span>                                 <span class="c1">//EN Weight</span>
    <span class="n">PMC_BIRTH</span><span class="p">,</span>                                  <span class="c1">//EN Time of birth</span>
    <span class="n">PMC_SEX</span><span class="p">,</span>                                    <span class="c1">//EN Sex</span>
    <span class="n">PMC_ROLE</span>                                    <span class="c1">//EN Role in family </span>
<span class="p">};</span>



<span class="n">range</span> <span class="n">FAM_ID</span><span class="p">{</span> <span class="mi">0</span><span class="p">,</span><span class="mi">220000</span> <span class="p">};</span>                       <span class="c1">//EN Range of Family IDs</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// Parameters                                                               </span>
<span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>

<span class="n">parameters</span>
<span class="p">{</span>
    <span class="n">file</span>    <span class="n">MicroDataInputFile</span><span class="p">;</span>                 <span class="c1">//EN File name of starting population</span>
    <span class="kt">long</span>    <span class="n">MicroDataInputFileSize</span><span class="p">;</span>             <span class="c1">//EN File size of starting population</span>
    <span class="kt">double</span>  <span class="n">StartPopSampleSize</span><span class="p">;</span>                 <span class="c1">//EN Simulated sample size of starting population</span>
    <span class="kt">double</span>  <span class="n">StartPopSize</span><span class="p">;</span>                       <span class="c1">//EN Real population size</span>
<span class="p">};</span>

<span class="n">parameter_group</span> <span class="n">PG_ModelSettings</span>                <span class="c1">//EN Starting population</span>
<span class="p">{</span>
    <span class="n">MicroDataInputFile</span><span class="p">,</span> <span class="n">MicroDataInputFileSize</span><span class="p">,</span>
    <span class="n">StartPopSampleSize</span><span class="p">,</span> <span class="n">StartPopSize</span>
<span class="p">};</span>


<span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// Actor-Sets                                                                         </span>
<span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>

<span class="c1">//EN Actor-set of all family heads in Observations </span>
<span class="n">actor_set</span> <span class="n">Observation</span> <span class="n">asObservationHeads</span> <span class="n">filter</span> <span class="n">fam_role</span> <span class="o">==</span> <span class="n">FR_HEAD</span> <span class="o">&amp;&amp;</span> <span class="n">obs_weight</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>  

<span class="c1">//EN Actor-set of all family members (without heatds) by family ID</span>
<span class="n">actor_set</span> <span class="n">Observation</span> <span class="n">asObservationNonHeads</span><span class="p">[</span><span class="n">fam_id</span><span class="p">]</span> <span class="n">filter</span> <span class="n">fam_role</span> <span class="o">!=</span> <span class="n">FR_HEAD</span><span class="p">;</span>         

<span class="c1">//EN All observations</span>
<span class="n">actor_set</span> <span class="n">Observation</span> <span class="n">asObservationAll</span><span class="p">;</span>                                                    

<span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// Actor states and functions                                                     </span>
<span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>

<span class="cm">/*  NOTE(Observation, EN)</span>
<span class="cm">    The Actor Observation is created as internal representation of the starting population file </span>
<span class="cm">    records. It is used to create Person actors of the starting population which can be smaller or</span>
<span class="cm">    larger as the starting population file. The weights of observations are used for determining if</span>
<span class="cm">    and how often a single observation is represented in the starting population.</span>
<span class="cm">*/</span>


<span class="n">actor</span> <span class="n">Observation</span>                               <span class="c1">//EN Actor Observations</span>
<span class="p">{</span>
    <span class="kt">double</span>      <span class="n">pmc</span><span class="p">[</span><span class="n">PERSON_MICRODATA_COLUMNS</span><span class="p">];</span>  <span class="c1">//EN Person micro record columns</span>
    <span class="n">integer</span>     <span class="n">obs_weight</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span> <span class="p">};</span>             <span class="c1">//EN Observation integer weight</span>
    <span class="n">FAM_ID</span>      <span class="n">fam_id</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>                 <span class="c1">//EN Family ID</span>
    <span class="n">FAM_ROLE</span>    <span class="n">fam_role</span> <span class="o">=</span> <span class="p">{</span> <span class="n">FR_HEAD</span> <span class="p">};</span>         <span class="c1">//EN Role in family</span>

    <span class="kt">void</span>        <span class="nf">Start</span><span class="p">(</span><span class="k">const</span> <span class="n">input_csv</span><span class="o">&amp;</span> <span class="n">input</span><span class="p">);</span>  <span class="c1">//EN Function starting the actor</span>
    <span class="kt">void</span>        <span class="nf">Finish</span><span class="p">();</span>                       <span class="c1">//EN Function destroying the actor</span>
<span class="p">};</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// Implementation                                                                       </span>
<span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>

<span class="kt">void</span> <span class="n">Observation</span><span class="o">::</span><span class="n">Start</span><span class="p">(</span><span class="k">const</span> <span class="n">input_csv</span><span class="o">&amp;</span> <span class="n">in_csv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">nJ</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">nJ</span> <span class="o">&lt;</span> <span class="n">SIZE</span><span class="p">(</span><span class="n">PERSON_MICRODATA_COLUMNS</span><span class="p">);</span> <span class="n">nJ</span><span class="o">++</span><span class="p">)</span> 
    <span class="p">{</span>
        <span class="n">pmc</span><span class="p">[</span><span class="n">nJ</span><span class="p">]</span> <span class="o">=</span> <span class="n">in_csv</span><span class="p">[</span><span class="n">nJ</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="n">fam_id</span>      <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">pmc</span><span class="p">[</span><span class="n">PMC_HHID</span><span class="p">];</span>
    <span class="n">fam_role</span>    <span class="o">=</span> <span class="p">(</span><span class="n">FAM_ROLE</span><span class="p">)(</span><span class="kt">int</span><span class="p">)</span><span class="n">pmc</span><span class="p">[</span><span class="n">PMC_ROLE</span><span class="p">];</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">Observation</span><span class="o">::</span><span class="n">Finish</span><span class="p">(){};</span>
</pre></div>
</div>
</div>
<div class="section" id="personcore-mpp">
<span id="personcore-mpp"></span><h3>3.2.4.6. PersonCore.mpp<a class="headerlink" href="#personcore-mpp" title="Permalink to this headline">¶</a></h3>
<p>This module introduces the main actor of the model: Person. It contains the core functionality and general states of the actor Person. Each actor typically has a ‘Core’ module for handling general functionalities of the actor. The most essential functions of this module are the Start() and Finish() functions of the actor. Start() is called when an actor is created and initializes all states. It is the only place where the automatically provided states age and time can be set.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// Dimensions                                                                                    </span>
<span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>

<span class="n">classification</span> <span class="n">SEX</span>                              <span class="c1">//EN Sex</span>
<span class="p">{</span>
    <span class="n">FEMALE</span><span class="p">,</span>                                     <span class="c1">//EN Female</span>
    <span class="n">MALE</span>                                        <span class="c1">//EN Male</span>
<span class="p">};</span>

<span class="n">classification</span> <span class="n">PERSON_TYPE</span>                      <span class="c1">//EN Person Type</span>
<span class="p">{</span>
    <span class="n">PT_START</span><span class="p">,</span>                                   <span class="c1">//EN Person from Starting Population</span>
    <span class="n">PT_CHILD</span><span class="p">,</span>                                   <span class="c1">//EN Person born in simulation</span>
    <span class="n">PT_IMMIGRANT</span>                                <span class="c1">//EN Immigrant    </span>
<span class="p">};</span>

<span class="n">classification</span> <span class="n">FAM_ROLE</span>                         <span class="c1">//EN Role in family</span>
<span class="p">{</span>
    <span class="n">FR_HEAD</span><span class="p">,</span>                                    <span class="c1">//EN Head </span>
    <span class="n">FR_SPOUSE</span><span class="p">,</span>                                  <span class="c1">//EN Spouse of head</span>
    <span class="n">FR_CHILD</span>                                    <span class="c1">//EN Child</span>
<span class="p">};</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// Links                                                                          </span>
<span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>

<span class="n">link</span> <span class="n">Person</span><span class="p">.</span><span class="n">lParent</span> <span class="n">Person</span><span class="p">.</span><span class="n">mlChild</span><span class="p">[];</span>           <span class="c1">//EN Link between Head and Children </span>
<span class="n">link</span> <span class="n">Person</span><span class="p">.</span><span class="n">lSpouse</span><span class="p">;</span>                            <span class="c1">//EN Link between spouses</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// Actor sets                                                          </span>
<span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>

<span class="n">actor_set</span> <span class="n">Person</span> <span class="n">asAllPersons</span> <span class="n">filter</span> <span class="n">is_alive</span><span class="p">;</span>  <span class="c1">//EN Entire population</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// Actor states and functions                                                         </span>
<span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>

<span class="cm">/*  NOTE(Person, EN)</span>
<span class="cm">    The actors Person are the main actors of the simulation. All persons have the</span>
<span class="cm">    same weight and together represent the population.</span>
<span class="cm">*/</span>

<span class="n">actor</span> <span class="n">Person</span>            
<span class="p">{</span>
    <span class="n">PERSON_TYPE</span>     <span class="n">person_type</span> <span class="o">=</span> <span class="p">{</span> <span class="n">PT_START</span> <span class="p">};</span>                     <span class="c1">//EN Person type</span>
    <span class="kt">double</span>          <span class="n">time_of_birth</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1900</span> <span class="p">};</span>                       <span class="c1">//EN Time of birth    </span>
    <span class="n">ALL_YEAR_RANGE</span>  <span class="n">year_of_birth</span> <span class="o">=</span> <span class="kt">int</span><span class="p">(</span><span class="n">time_of_birth</span><span class="p">);</span>             <span class="c1">//EN Year of birth</span>
    <span class="n">SEX</span>             <span class="n">sex</span> <span class="o">=</span> <span class="p">{</span> <span class="n">FEMALE</span> <span class="p">};</span>                               <span class="c1">//EN Sex</span>
    <span class="n">FAM_ROLE</span>        <span class="n">family_role</span> <span class="o">=</span> <span class="p">{</span> <span class="n">FR_HEAD</span> <span class="p">};</span>                      <span class="c1">//EN Family Role</span>

    <span class="kt">void</span>            <span class="nf">Start</span><span class="p">(</span><span class="n">Observation</span> <span class="o">*</span><span class="n">peObservation</span><span class="p">,</span> <span class="n">Person</span> <span class="o">*</span><span class="n">pePers</span><span class="p">);</span>  <span class="c1">//EN Starts the actor</span>
    <span class="kt">void</span>            <span class="nf">Finish</span><span class="p">();</span>                                           <span class="c1">//EN Finishes the actor</span>

    <span class="n">logical</span>         <span class="n">is_alive</span> <span class="o">=</span> <span class="p">{</span> <span class="n">FALSE</span> <span class="p">};</span>                           <span class="c1">//EN Person is alive</span>
    <span class="kt">double</span>          <span class="n">time_set_alive</span> <span class="o">=</span> <span class="p">{</span> <span class="n">TIME_INFINITE</span> <span class="p">};</span>             <span class="c1">//EN Time setting actor alive</span>
    <span class="n">event</span>           <span class="n">timeSetAliveEvent</span><span class="p">,</span> <span class="n">SetAliveEvent</span><span class="p">;</span>               <span class="c1">//EN Set Alive</span>

    <span class="n">Person</span>          <span class="o">*</span><span class="n">peHHead</span><span class="p">;</span>                                       <span class="c1">//EN Pointer to household head</span>

<span class="p">};</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// Implementation                                                                               </span>
<span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>

<span class="cm">/*  NOTE(Person.Start, EN)</span>
<span class="cm">    The Start() function initializes all states of an actor right at the moment of creation.</span>
<span class="cm">    The function has two parameters, namely pointers to an observation actor and to the household </span>
<span class="cm">    head. If the pointer to an observation is not NULL, the Person comes from the starting </span>
<span class="cm">    population (rather than being born or immigrating in the simulation). The pointer is used to</span>
<span class="cm">    access all states of the observation. The pointer to the househod head is used to establish a</span>
<span class="cm">    link to the family head which can be a parent or a spouse. If the parameter is NULL, the Person</span>
<span class="cm">    is a family head herself.</span>
<span class="cm">*/</span>

<span class="kt">void</span> <span class="n">Person</span><span class="o">::</span><span class="n">Start</span><span class="p">(</span><span class="n">Observation</span> <span class="o">*</span><span class="n">peObservation</span><span class="p">,</span> <span class="n">Person</span> <span class="o">*</span><span class="n">pePers</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Setting the actor weight</span>
    <span class="n">Set_actor_weight</span><span class="p">(</span><span class="n">asGlobals</span><span class="o">-&gt;</span><span class="n">Item</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">person_weight</span><span class="p">);</span>
    <span class="n">Set_actor_subsample_weight</span><span class="p">(</span><span class="n">asGlobals</span><span class="o">-&gt;</span><span class="n">Item</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">person_weight</span><span class="p">);</span>

    <span class="c1">// Determine the person type</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">peObservation</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">pePers</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="n">person_type</span> <span class="o">=</span> <span class="n">PT_CHILD</span><span class="p">;</span>   <span class="c1">// Born in simulation</span>
    <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">peObservation</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="n">person_type</span> <span class="o">=</span> <span class="n">PT_START</span><span class="p">;</span>                <span class="c1">// From Starting Pop</span>
    <span class="k">else</span> <span class="n">person_type</span> <span class="o">=</span> <span class="n">PT_IMMIGRANT</span><span class="p">;</span>                                        <span class="c1">// Immigrant    </span>

    <span class="c1">// Initialize states</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">person_type</span> <span class="o">==</span> <span class="n">PT_START</span><span class="p">)</span> <span class="c1">// Person comes from starting population</span>
    <span class="p">{</span>
        <span class="c1">// (A) States from Starting population file</span>
        <span class="n">time</span>                <span class="o">=</span> <span class="n">peObservation</span><span class="o">-&gt;</span><span class="n">pmc</span><span class="p">[</span><span class="n">PMC_BIRTH</span><span class="p">]</span> <span class="o">+</span> <span class="n">RandUniform</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
        <span class="n">sex</span>                 <span class="o">=</span> <span class="p">(</span><span class="n">SEX</span><span class="p">)(</span><span class="kt">int</span><span class="p">)</span><span class="n">peObservation</span><span class="o">-&gt;</span><span class="n">pmc</span><span class="p">[</span><span class="n">PMC_SEX</span><span class="p">];</span>
        <span class="n">family_role</span> <span class="o">=</span> <span class="p">(</span> <span class="n">FAM_ROLE</span> <span class="p">)(</span> <span class="kt">int</span> <span class="p">)</span><span class="n">peObservation</span><span class="o">-&gt;</span><span class="n">pmc</span><span class="p">[</span><span class="n">PMC_ROLE</span><span class="p">];</span>

        <span class="c1">// (B) Other states </span>
        <span class="n">time_of_birth</span>       <span class="o">=</span> <span class="n">time</span><span class="p">;</span>
        <span class="n">calendar_year</span>       <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">time_of_birth</span><span class="p">;</span>

        <span class="c1">// (C) Links to head resp. spouse</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pePers</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="n">peHHead</span> <span class="o">=</span> <span class="n">pePers</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">person_type</span> <span class="o">==</span> <span class="n">PT_CHILD</span><span class="p">)</span> <span class="c1">// Person born in simulation </span>
    <span class="p">{</span>
        <span class="c1">// do nothing (births not modeled yet)</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="c1">// Person is an immigrant</span>
    <span class="p">{</span>
        <span class="c1">// do nothing (immigrants not modeled yet)</span>
    <span class="p">}</span>
    <span class="n">time_set_alive</span> <span class="o">=</span> <span class="n">WAIT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*  NOTE(Person.Finish, EN)</span>
<span class="cm">    Finish is a function to be called when an actor is to be destroyed. Modgen automatically</span>
<span class="cm">    performs memory clean-up routines. Code added here is the last thing executed before an actor </span>
<span class="cm">    is destroyed. Typical uses are the handling of inheritances and accounting routines.</span>
<span class="cm">*/</span>
<span class="kt">void</span> <span class="n">Person</span><span class="o">::</span><span class="n">Finish</span><span class="p">(){}</span>


<span class="cm">/*  NOTE(Person.SetAliveEvent, EN)</span>
<span class="cm">    This function is called with waiting time 0 immediately after the Start of a Person actor. </span>
<span class="cm">    For people of the starting population the date of birth is only known after getting this </span>
<span class="cm">    information from the corresponding person record, thus after the person actor is created. </span>
<span class="cm">    The SetAliveEvent Event ensures that no person is visible and counted before its actual </span>
<span class="cm">    birth date. </span>
<span class="cm">*/</span>

<span class="n">TIME</span> <span class="n">Person</span><span class="o">::</span><span class="n">timeSetAliveEvent</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">time_set_alive</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">void</span> <span class="n">Person</span><span class="o">::</span><span class="n">SetAliveEvent</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">lClock</span>         <span class="o">=</span> <span class="n">asTheClock</span><span class="o">-&gt;</span><span class="n">Item</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>       <span class="c1">// link the person to the clock</span>
    <span class="n">is_alive</span>       <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>                      <span class="c1">// set the Person alive    </span>
    <span class="n">time_set_alive</span> <span class="o">=</span> <span class="n">TIME_INFINITE</span><span class="p">;</span>             <span class="c1">// ensure the event does not happen again</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">person_type</span> <span class="o">==</span> <span class="n">PT_START</span> <span class="o">&amp;&amp;</span> <span class="n">family_role</span> <span class="o">!=</span> <span class="n">FR_HEAD</span> <span class="o">&amp;&amp;</span> <span class="n">peHHead</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">family_role</span> <span class="o">==</span> <span class="n">FR_CHILD</span><span class="p">)</span> <span class="n">lParent</span> <span class="o">=</span> <span class="n">peHHead</span><span class="p">;</span>          <span class="c1">// Person is a child</span>
        <span class="k">else</span> <span class="n">lSpouse</span> <span class="o">=</span> <span class="n">peHHead</span><span class="p">;</span>                                  <span class="c1">// Person is a spouse</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="clockcore-mpp">
<span id="clockcore-mpp"></span><h3>3.2.4.7. ClockCore.mpp<a class="headerlink" href="#clockcore-mpp" title="Permalink to this headline">¶</a></h3>
<p>This module introduces a Clock actor which handles calendar clock events like year changes. This avoids inefficiencies as otherwise all actors would having to schedule their own events for year change. Instead of that the Clock announces each year end/start to all other actors</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// Links                                                                                           </span>
<span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>

<span class="n">link</span> <span class="n">Person</span><span class="p">.</span><span class="n">lClock</span> <span class="n">Clock</span><span class="p">.</span><span class="n">mlPersons</span><span class="p">[];</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// Clock Actor                                                  </span>
<span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>

<span class="cm">/*  NOTE (Clock, EN)</span>
<span class="cm">    The Clock actor handles calendar year and other regular period changes. </span>
<span class="cm">*/</span>

<span class="n">actor</span> <span class="n">Clock</span>                                                 <span class="c1">//EN Clock Actor</span>
<span class="p">{</span>
    <span class="kt">void</span>    <span class="n">Start</span><span class="p">();</span>                                        <span class="c1">//EN Start Clock</span>
    <span class="kt">void</span>    <span class="nf">Finish</span><span class="p">();</span>                                       <span class="c1">//EN Finish</span>
    <span class="kt">int</span>     <span class="n">clock_year</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">2000</span> <span class="p">};</span>                          <span class="c1">//EN Calendar Year</span>
    <span class="kt">int</span>     <span class="n">next_clock_year_end</span> <span class="o">=</span> <span class="p">{</span> <span class="n">TIME_INFINITE</span> <span class="p">};</span>        <span class="c1">//EN Next end year clock tick</span>
    <span class="kt">int</span>     <span class="n">next_clock_year_start</span> <span class="o">=</span> <span class="p">{</span> <span class="n">TIME_INFINITE</span> <span class="p">};</span>      <span class="c1">//EN Next start year clock tick</span>
    <span class="n">event</span>   <span class="n">timeStartYearClock</span><span class="p">,</span> <span class="n">StartYearClock</span><span class="p">;</span>             <span class="c1">//EN Start year function of clock</span>
    <span class="n">event</span>   <span class="n">timeEndYearClock</span><span class="p">,</span> <span class="n">EndYearClock</span><span class="p">;</span>                 <span class="c1">//EN End year function of clock</span>
<span class="p">};</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// Actor sets                                                                                    </span>
<span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>

<span class="n">actor_set</span> <span class="n">Clock</span> <span class="n">asTheClock</span><span class="p">;</span>                                 <span class="c1">//EN Actor Set Clock Actor</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// Implementation                                                     </span>
<span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>

<span class="kt">void</span> <span class="n">Clock</span><span class="o">::</span><span class="n">Start</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">time</span> <span class="o">=</span> <span class="n">MIN</span><span class="p">(</span><span class="n">ALL_YEAR_RANGE</span><span class="p">);</span>
    <span class="n">clock_year</span> <span class="o">=</span> <span class="n">MIN</span><span class="p">(</span><span class="n">ALL_YEAR_RANGE</span><span class="p">);</span>
    <span class="n">next_clock_year_end</span> <span class="o">=</span> <span class="n">WAIT</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">Clock</span><span class="o">::</span><span class="n">Finish</span><span class="p">()</span> <span class="p">{}</span>

<span class="cm">/*  NOTE( Clock.EndYearClock, EN)</span>
<span class="cm">    The function EndYearClock creates an end of year event. It calls all other actors to announce </span>
<span class="cm">    that the year has ended so that all actors can perform their own end of year routines</span>
<span class="cm">*/</span>

<span class="n">TIME</span> <span class="n">Clock</span><span class="o">::</span><span class="n">timeEndYearClock</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">next_clock_year_end</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">void</span> <span class="n">Clock</span><span class="o">::</span><span class="n">EndYearClock</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">long</span> <span class="n">nPopSize</span> <span class="o">=</span> <span class="n">asAllPersons</span><span class="o">-&gt;</span><span class="n">Count</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="n">nIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">nIndex</span> <span class="o">&lt;</span> <span class="n">nPopSize</span><span class="p">;</span> <span class="n">nIndex</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">prPerson</span> <span class="o">=</span> <span class="n">asAllPersons</span><span class="o">-&gt;</span><span class="n">Item</span><span class="p">(</span><span class="n">nIndex</span><span class="p">);</span>
        <span class="n">prPerson</span><span class="o">-&gt;</span><span class="n">YearEnd</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">next_clock_year_start</span> <span class="o">=</span> <span class="n">WAIT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">next_clock_year_end</span> <span class="o">=</span> <span class="n">WAIT</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*  NOTE( Clock.StartYearClock, EN)</span>
<span class="cm">    The function StartYearClock creates a new year event. It calls all other actors to announce </span>
<span class="cm">    that a new year has started so that all actors can call their own new year routines</span>
<span class="cm">*/</span>

<span class="n">TIME</span> <span class="n">Clock</span><span class="o">::</span><span class="n">timeStartYearClock</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">next_clock_year_start</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">void</span> <span class="n">Clock</span><span class="o">::</span><span class="n">StartYearClock</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">clock_year</span><span class="o">++</span><span class="p">;</span>
    <span class="kt">long</span> <span class="n">nPopSize</span> <span class="o">=</span> <span class="n">asAllPersons</span><span class="o">-&gt;</span><span class="n">Count</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="n">nIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">nIndex</span> <span class="o">&lt;</span> <span class="n">nPopSize</span><span class="p">;</span> <span class="n">nIndex</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">prPerson</span> <span class="o">=</span> <span class="n">asAllPersons</span><span class="o">-&gt;</span><span class="n">Item</span><span class="p">(</span><span class="n">nIndex</span><span class="p">);</span>
        <span class="n">prPerson</span><span class="o">-&gt;</span><span class="n">YearStart</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">next_clock_year_start</span> <span class="o">=</span> <span class="n">TIME_INFINITE</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="calendaryearchange-mpp">
<span id="calendaryearchange-mpp"></span><h3>3.2.4.8. CalendarYearChange.mpp<a class="headerlink" href="#calendaryearchange-mpp" title="Permalink to this headline">¶</a></h3>
<p>This module handles calendar year changes. Before a year ends, the Person function YearEnd() is called by the Calendar clock actor. This is a point in time in which models typically update accounts and perform other end of year routines. Immediately after the year end, the YearStart() routine is called. This is when the calendar_year state is changed.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// Actor Person states and functions                                               </span>
<span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>

<span class="n">actor</span> <span class="n">Person</span>                                                        
<span class="p">{</span>
    <span class="n">ALL_YEAR_RANGE</span>  <span class="n">calendar_year</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">2000</span> <span class="p">};</span>                       <span class="c1">//EN Calendar year  </span>
    <span class="kt">void</span>            <span class="nf">YearEnd</span><span class="p">();</span>                                      <span class="c1">//EN Year End Function</span>
    <span class="kt">void</span>            <span class="nf">YearStart</span><span class="p">();</span>                                    <span class="c1">//EN Year Start Function</span>
<span class="p">};</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// Implementation                                                                  </span>
<span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>

<span class="cm">/*  NOTE(Person.YearEnd, EN)</span>
<span class="cm">    The function YearEnd is called by the Clock actor at the end of each year. The code in this </span>
<span class="cm">    function is executed last thing in a given year before the calendar year is incremented</span>
<span class="cm">*/</span>

<span class="kt">void</span> <span class="n">Person</span><span class="o">::</span><span class="n">YearEnd</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// empty for the moment</span>
<span class="p">}</span>

<span class="cm">/*  NOTE(Person.YearEnd, EN)</span>
<span class="cm">    The function YearStart is called by the Clock actor at the start of each year.</span>
<span class="cm">    The code in this function is executed first thing in new year</span>
<span class="cm">*/</span>
<span class="kt">void</span> <span class="n">Person</span><span class="o">::</span><span class="n">YearStart</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">calendar_year</span> <span class="o">=</span> <span class="n">lClock</span><span class="o">-&gt;</span><span class="n">clock_year</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="globalscore-mpp">
<span id="globalscore-mpp"></span><h3>3.2.4.9. GlobalsCore.mpp<a class="headerlink" href="#globalscore-mpp" title="Permalink to this headline">¶</a></h3>
<p>This module introduces an actor Globals which handles global variables and constants which are calculated or changed after the pre-simulation phase.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">actor_set</span> <span class="n">Globals</span> <span class="n">asGlobals</span><span class="p">;</span>                    <span class="c1">//EN Globals (Actor Set)    </span>

<span class="n">actor</span> <span class="n">Globals</span>                                   <span class="c1">//EN Actor Globals </span>
<span class="p">{</span>
    <span class="kt">double</span> <span class="n">person_weight</span> <span class="o">=</span> <span class="p">{</span> <span class="mf">1.0</span> <span class="p">};</span>             <span class="c1">//EN Person weight</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="microdataoutput-mpp">
<span id="microdataoutput-mpp"></span><h3>3.2.4.10. MicroDataOutput.mpp<a class="headerlink" href="#microdataoutput-mpp" title="Permalink to this headline">¶</a></h3>
<p>This module implements micro data output written to a csv file. Users can specify the time at which a micro-data file is written out and choose a file name. Output can also be produced in fixed time intervals, e.g. every year or every 5 years. The output csv file includes a header line with variable names. The module can be switched on and off.</p>
<p><strong>How to add a new variable to the output?</strong></p>
<ul class="simple">
<li>In WriteMicroRecord(), add a line which pushes a new variable into the output record</li>
<li>In PreSimulation() add a line to extend the list of variable names written to the file</li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">output_csv</span> <span class="n">out_csv</span><span class="p">;</span>                                 <span class="c1">//EN Microdata output csv object</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// Types</span>
<span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>

<span class="n">classification</span> <span class="n">OUTPUT_TIMES</span>                         <span class="c1">//EN Micro-data output times</span>
<span class="p">{</span>
    <span class="n">OT_FIRST</span><span class="p">,</span>                                       <span class="c1">//EN Time of first output            </span>
    <span class="n">OT_LAST</span><span class="p">,</span>                                        <span class="c1">//EN Time of last output</span>
    <span class="n">OT_INTERVAL</span>                                     <span class="c1">//EN Time interval (0 for no repetition)</span>
<span class="p">};</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// Parameters                                                                                   </span>
<span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>

<span class="n">parameters</span>
<span class="p">{</span>
    <span class="n">logical</span>     <span class="n">WriteMicrodata</span><span class="p">;</span>                     <span class="c1">//EN Write micro-data output file Y/N</span>
    <span class="kt">double</span>      <span class="n">TimeMicroOutput</span><span class="p">[</span><span class="n">OUTPUT_TIMES</span><span class="p">];</span>      <span class="c1">//EN Time(s) of micro-data output</span>
    <span class="n">file</span>        <span class="n">MicroRecordFileName</span><span class="p">;</span>                <span class="c1">//EN File name micro-data output file</span>
<span class="p">};</span>

<span class="n">parameter_group</span> <span class="n">PG05_Files</span>                          <span class="c1">//EN Microdata output</span>
<span class="p">{</span>
    <span class="n">WriteMicrodata</span><span class="p">,</span> <span class="n">MicroRecordFileName</span><span class="p">,</span> 
    <span class="n">TimeMicroOutput</span> 
<span class="p">};</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// Actor states, functions and events                                                          </span>
<span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>

<span class="n">actor</span> <span class="n">Person</span>
<span class="p">{</span>
    <span class="n">TIME</span>  <span class="n">time_microdata_output</span> <span class="o">=</span> <span class="p">{</span><span class="n">TIME_INFINITE</span><span class="p">};</span>  <span class="c1">//EN Time for microdata output</span>
    <span class="kt">void</span>  <span class="nf">WriteMicroRecord_Start</span><span class="p">();</span>                 <span class="c1">//EN Initialization for microdata output event</span>
    <span class="n">hook</span>  <span class="n">WriteMicroRecord_Start</span><span class="p">,</span> <span class="n">Start</span><span class="p">;</span>            <span class="c1">//EN Function Hook</span>
    <span class="n">event</span> <span class="n">timeWriteMicroRecord</span><span class="p">,</span> <span class="n">WriteMicroRecord</span><span class="p">;</span>   <span class="c1">//EN Write micro-data record event</span>
<span class="p">};</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// Implementation                                                                            </span>
<span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>

<span class="kt">void</span> <span class="n">Person</span><span class="o">::</span><span class="n">WriteMicroRecord_Start</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">double</span> <span class="n">dFirstOutput</span> <span class="o">=</span> <span class="n">TimeMicroOutput</span><span class="p">[</span><span class="n">OT_FIRST</span><span class="p">];</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">WriteMicrodata</span> <span class="o">&amp;&amp;</span> <span class="n">dFirstOutput</span> <span class="o">&lt;=</span> <span class="n">TimeMicroOutput</span><span class="p">[</span><span class="n">OT_LAST</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">dFirstOutput</span> <span class="o">&lt;</span> <span class="n">time</span><span class="p">)</span> 
    <span class="p">{</span>
        <span class="n">dFirstOutput</span> <span class="o">=</span> <span class="n">dFirstOutput</span> <span class="o">+</span> <span class="n">TimeMicroOutput</span><span class="p">[</span><span class="n">OT_INTERVAL</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">TimeMicroOutput</span><span class="p">[</span><span class="n">OT_INTERVAL</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">)</span> <span class="n">dFirstOutput</span> <span class="o">=</span> <span class="n">TIME_INFINITE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">WriteMicrodata</span> <span class="o">&amp;&amp;</span> <span class="n">dFirstOutput</span> <span class="o">&gt;=</span> <span class="n">time</span> <span class="o">&amp;&amp;</span> <span class="n">dFirstOutput</span> <span class="o">&lt;=</span> <span class="n">TimeMicroOutput</span><span class="p">[</span><span class="n">OT_LAST</span><span class="p">])</span> 
    <span class="p">{</span>
        <span class="n">time_microdata_output</span> <span class="o">=</span> <span class="n">dFirstOutput</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="n">time_microdata_output</span> <span class="o">=</span> <span class="n">TIME_INFINITE</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">TIME</span> <span class="n">Person</span><span class="o">::</span><span class="n">timeWriteMicroRecord</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">GetReplicate</span><span class="p">()</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>  <span class="k">return</span> <span class="n">time_microdata_output</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">return</span> <span class="n">TIME_INFINITE</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Person</span><span class="o">::</span><span class="n">WriteMicroRecord</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// create output variables for linked actors</span>
    <span class="kt">long</span> <span class="n">nSpouseID</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="k">if</span> <span class="p">(</span><span class="n">lSpouse</span><span class="p">)</span> <span class="n">nSpouseID</span> <span class="o">=</span> <span class="n">lSpouse</span><span class="o">-&gt;</span><span class="n">actor_id</span><span class="p">;</span>
    <span class="kt">long</span> <span class="n">nParentID</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="k">if</span> <span class="p">(</span><span class="n">lParent</span><span class="p">)</span> <span class="n">nParentID</span> <span class="o">=</span> <span class="n">lParent</span><span class="o">-&gt;</span><span class="n">actor_id</span><span class="p">;</span>

    <span class="c1">// Push the fields into the output record.</span>

    <span class="c1">// ==============================================================</span>
    <span class="c1">// When adding additional variables, this list has to be extended</span>
    <span class="c1">// ==============================================================</span>
    <span class="n">out_csv</span> <span class="o">&lt;&lt;</span> <span class="n">actor_id</span><span class="p">;</span>            <span class="c1">// Actor ID</span>
    <span class="n">out_csv</span> <span class="o">&lt;&lt;</span> <span class="n">actor_weight</span><span class="p">;</span>        <span class="c1">// Weight</span>
    <span class="n">out_csv</span> <span class="o">&lt;&lt;</span> <span class="n">time</span><span class="p">;</span>                <span class="c1">// Time</span>
    <span class="n">out_csv</span> <span class="o">&lt;&lt;</span> <span class="n">nSpouseID</span><span class="p">;</span>           <span class="c1">// Spouse ID</span>
    <span class="n">out_csv</span> <span class="o">&lt;&lt;</span> <span class="n">nParentID</span><span class="p">;</span>           <span class="c1">// Parent ID </span>
    <span class="n">out_csv</span> <span class="o">&lt;&lt;</span> <span class="n">time_of_birth</span><span class="p">;</span>       <span class="c1">// Time of birth</span>
    <span class="n">out_csv</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">sex</span><span class="p">;</span>            <span class="c1">// Sex</span>

    <span class="c1">// All fields have been pushed, now write the record.</span>
    <span class="n">out_csv</span><span class="p">.</span><span class="n">write_record</span><span class="p">();</span>

    <span class="c1">// set next output</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">time_microdata_output</span> <span class="o">+</span> <span class="n">TimeMicroOutput</span><span class="p">[</span><span class="n">OT_INTERVAL</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">time</span> <span class="o">&amp;&amp;</span>
        <span class="n">time_microdata_output</span> <span class="o">+</span> <span class="n">TimeMicroOutput</span><span class="p">[</span><span class="n">OT_INTERVAL</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">TimeMicroOutput</span><span class="p">[</span><span class="n">OT_LAST</span><span class="p">])</span>
    <span class="p">{</span>
        <span class="n">time_microdata_output</span> <span class="o">=</span> <span class="n">time_microdata_output</span> <span class="o">+</span> <span class="n">TimeMicroOutput</span><span class="p">[</span><span class="n">OT_INTERVAL</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">time_microdata_output</span> <span class="o">=</span> <span class="n">TIME_INFINITE</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// Pre- and Post-Simulation                                                           </span>
<span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>

<span class="kt">void</span> <span class="n">PreSimulation</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// In the pre-simulation phase of MicroDataOutput.mpp module, the micro-data file is prepared</span>
    <span class="c1">// for writing records in the simulation. If the user selects micro-data output, a file is </span>
    <span class="c1">// opened and the header row is written containing all selected states</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">WriteMicrodata</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// ==============================================================</span>
        <span class="c1">// When adding additional variables, this list has to be extended</span>
        <span class="c1">// ==============================================================</span>
        <span class="n">std_string</span> <span class="n">myString</span> <span class="o">=</span> <span class="s">&quot;ID,&quot;</span><span class="p">;</span>        <span class="c1">// Actor ID</span>
        <span class="n">myString</span> <span class="o">=</span> <span class="n">myString</span> <span class="o">+</span> <span class="s">&quot;WEIGHT,&quot;</span><span class="p">;</span>    <span class="c1">// Weight</span>
        <span class="n">myString</span> <span class="o">=</span> <span class="n">myString</span> <span class="o">+</span> <span class="s">&quot;TIME,&quot;</span><span class="p">;</span>      <span class="c1">// Time</span>
        <span class="n">myString</span> <span class="o">=</span> <span class="n">myString</span> <span class="o">+</span> <span class="s">&quot;SPOUSE_ID,&quot;</span><span class="p">;</span> <span class="c1">// Spouse</span>
        <span class="n">myString</span> <span class="o">=</span> <span class="n">myString</span> <span class="o">+</span> <span class="s">&quot;PARENT_ID,&quot;</span><span class="p">;</span> <span class="c1">// Parent</span>
        <span class="n">myString</span> <span class="o">=</span> <span class="n">myString</span> <span class="o">+</span> <span class="s">&quot;BIRTH,&quot;</span><span class="p">;</span>     <span class="c1">// Time of birth</span>
        <span class="n">myString</span> <span class="o">=</span> <span class="n">myString</span> <span class="o">+</span> <span class="s">&quot;MALE,&quot;</span><span class="p">;</span>      <span class="c1">// Sex</span>
        
        <span class="n">out_csv</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="n">MicroRecordFileName</span><span class="p">);</span>
        <span class="n">out_csv</span><span class="p">.</span><span class="n">write_header</span><span class="p">(</span><span class="n">myString</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">PostSimulation</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">WriteMicrodata</span><span class="p">)</span> <span class="p">{</span> <span class="n">out_csv</span><span class="p">.</span><span class="n">close</span><span class="p">();</span> <span class="p">}</span> <span class="c1">// closing the file</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="tables-mpp">
<span id="tables-mpp"></span><h3>3.2.4.11. Tables.mpp<a class="headerlink" href="#tables-mpp" title="Permalink to this headline">¶</a></h3>
<p>This module contains the output tables of the model</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// Population Tables                                                                             </span>
<span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>

<span class="n">table_group</span> <span class="n">TG_PopulationTables</span>             <span class="c1">//EN Population </span>
<span class="p">{</span>
    <span class="n">TotalPopulation</span><span class="p">,</span> 
    <span class="n">StartingPopulationSummary</span>
<span class="p">};</span>

<span class="n">table</span> <span class="n">Person</span> <span class="n">TotalPopulation</span>                <span class="c1">//EN Total Population</span>
<span class="p">{</span>
    <span class="p">{</span>
        <span class="n">unit</span><span class="p">,</span>                               <span class="c1">//EN Persons at the beginning of each year</span>
        <span class="n">duration</span><span class="p">()</span>                          <span class="c1">//EN Average population (total time lived) in year</span>
    <span class="p">}</span>
    <span class="o">*</span> <span class="n">calendar_year</span>
    <span class="o">*</span> <span class="n">sex</span> <span class="o">+</span>
<span class="p">};</span>


<span class="n">table</span> <span class="n">Person</span> <span class="n">StartingPopulationSummary</span>      <span class="c1">//EN Starting Population Summary </span>
<span class="p">[</span><span class="n">person_type</span> <span class="o">==</span> <span class="n">PT_START</span><span class="p">]</span>
<span class="p">{</span>
    <span class="p">{</span>
        <span class="n">unit</span>                                <span class="c1">//EN Persons</span>
    <span class="p">}</span>
    <span class="o">*</span> <span class="n">year_of_birth</span> <span class="o">+</span>
    <span class="o">*</span> <span class="n">sex</span> <span class="o">+</span>
<span class="p">};</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// Birth Tables                                                                                 </span>
<span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>

<span class="n">table_group</span> <span class="n">TG_BirthTables</span>                  <span class="c1">//EN Births </span>
<span class="p">{</span>
    <span class="n">Births</span>
<span class="p">};</span>

<span class="n">table</span> <span class="n">Person</span> <span class="n">Births</span>                         <span class="c1">//EN Births</span>
<span class="p">{</span>
    <span class="p">{</span>
        <span class="n">transitions</span><span class="p">(</span><span class="n">is_alive</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">)</span>  <span class="c1">//EN Births</span>
    <span class="p">}</span>
    <span class="o">*</span><span class="n">calendar_year</span>
    <span class="o">*</span> <span class="n">sex</span> <span class="o">+</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="DYNAMIS-POP-Code-Intro.html" class="btn btn-neutral" title="3.1. The Modgen Micro-simulation Technology" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Martin Spielauer.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>